#!/bin/bash
# @(#) Remote (specific systems) exec (as root) script - V3.0.0 - Aug 28th 2019
###############################################################################
#                                                                             #
# Name of script:     launcher.sh                                             #
# Author:             Anthony Paardekooper (KSC) - Technical Unix/Linux       #
# Status:             Operational (after thoroughly being tested!!!).         #
# Version:            3.0.0                                                   #
# Date written:       Thursday, May 23rd 2019                                 #
# Date last modified:                                                         #
#          Anthony (2.0.2: Aug 7th 2019):                                     #
#          Accept the "no_password" as a password; meaning no password is     #
#          required for the usage of sudo (=SUDO-rule required!!!) and the    #
#          ssh-connections (=SSH-keys should be distributed!!!).              #
#          Added the -n[1|150] input variable; which is used to customize the #
#          maximum number of running back-ground (systems) processes. The     #
#          value should be between 1 and 150. When it is not specified, the   #
#          default number of 30 (such as set in ${MAX_PROC}) will be used.    #
#          In that case, make sure no more than 30 systems will be systems    #
#          running simultaneously running (until all systems are processed).  #
#          Modified the test to establish whether a system is operational;    #
#          replaced using ping by tcping.                                     #
#          Anthony (3.0.0: Aug 30th 2019):                                    #
#          - Changed the approach of processing the systems; not to be done   #
#            batch-wise anymore. Now process as much as systems (${MAX_PROC}) #
#            are allowed to be operational at the same time; as soon as a     #
#            file-descriptor becomes available, start a new system/process in #
#            it.                                                              #
#          - Added the recognition of "ranges" in the screen in which systems #
#            can be selected.                                                 #
#          - Added the recognition of the input-paramters:                    #
#            -w   : number of seconds to be waited before checking process(es)#
#                   are still running.                                        #
#            -D|S : either -D (do-not-use-sudo) or -S (do-use-sudo) must(!)   #
#                   be specified.                                             #
#            -f   : followed by the file-name containing the systems for      #
#                   which commands/scripts have to be processed on.           #
#          - When the user starts this script for the first time, a screen is #
#            displayed with some warnings and instructions.                   #
#          - In case of the -L option was specified (=<use-local-copy>), a    #
#            copy of the local script will also be displayed in the log-file. #
#          - Systems to be excluded by default (such as in: ${EXCLUDES}).     #
#                                                                             #
# Purpose: Shell-script to execute commands (as root: by using sudo or just   #
#          as the user itself; depending on the -D or -S input-parameter) on  #
#          specified/provided systems. In case of -S (=do-use-sudo) sudo-     #
#          access for the user/operator on the "remote system(s)" is required.#
#          The script runs remote execution-commands on specified system(s);  #
#          there will be ${MAX_PROC} (default 30 but can be op to max 150)    #
#          processes/systems running at the same time. As soon as 1 is done,  #
#          its result will be determined and a new will be started in order   #
#          to have continiously ${MAX_PROC} processing running until all      #
#          systems are processed.                                             #
#          Each remote execution-command (ssh (with sudo)) is started in the  #
#          background in a "dedicated file-descriptor". It's not allowed to   #
#          run any longer than 10 minutes (unless specified otherwise by the  #
#          "-m <max seconds>"); after that it will be killed if it is still   # 
#          running.                                                           #
#          In case of the -L option was specified (=<use-local-copy>), the    #
#          specified script (-x "<command to execute>"), the local-version    #
#          of the script is copied to the remote-system (into the directory:  #
#          /tmp/$(id -un)/$$/). That 1 will actually be called. So it is      #
#          actually not required that the script exists "remotely".           #
#          The script is copied into /tmp/.<user-name>/$$/<script-name>       #
#          to maintain its basename.                                          #
#                                                                             #
# START-LINE: DO NOT REMOVE ------------------------------------------------- #
#                                                                             #
# *************************************************************************** #
# *** Please Note: the script CAN be called with the operators password!  *** #
# *** Be careful! Provide the correct password... otherwise the operator  *** #
# *** can/will be locked...  :-(                                          *** #
# *************************************************************************** #
#                                                                             #
# Usage: From the command-line (not as root!) with a set of required and      #
#        optional input parameters passed on the script.                      #
#         ./launcher.sh                                                       #
#              +-----------------------------------------------+              #
#           -x "<command to execute>"                          |==> Required  #
#              Command/script must be specified between double quotes!        #
#              +-----------------------------------------------+              #
#           -A                                             -or-|              #
#           -t <PLANNED|OPERATION>                         -or-|              #
#           -s "<system>"                                  -or-|              #
#              Systems must be specified between double quotes!|==> Required  #
#           -e [environment]                               -or-|              #
#           -f <file>                                          |              #
#              File containing the systems                     |              #
#              +-----------------------------------------------+              #
#           -D [do-not-use-sudo]                           -or-|==> Required  #
#           -S [do-use-sudo]      **not allowed as root!**     |              #
#              +-----------------------------------------------+              #
#           -m [max seconds]                                   |==> Optional  #
#           -n [max processes]                                 |==> Optional  #
#           -p <password>         **not allowed as root!**     |==> Optional  #
#              *** Be careful with the option since the password will be ***  #
#              *** visible in plain text in the systems process-list!!!  ***  #
#              When the password: "no_password" was passed on the script,     #
#              no password should be required for both ssh-connection and     #
#              the sudo-usage!                                                #
#           -w [waiting seconds]                               |==> Optional  #
#           -L [use-local-copy]                                |==> Optional  #
#           -N [no-confirmations-asked]                        |==> Optional  #
#           -Q [quiet mode]                                    |==> Optional  #
#              +-----------------------------------------------+              #
#                                                                             #
#        For example:                                                         #
#         ./launcher.sh                                            \          #
#            -x "/tech/local/sbin/ignore-NW_down.sh --on;uptime"   \          #
#            -S                                                    \          #
#            -f /tmp/system-list                                   \          #
#            -p MyPass01!                                          \          #
#            -m 60                                                 \          #
#            -n 45                                                 \          #
#            -w 10                                                 \          #
#            -N                                                    \          #
#            -Q                                                               #
#                                                                             #
# By launching the script such as displayed in the example above, then the    #
# following will actually happen:                                             #
# 1.  [-x option]                                                             #
# The specified script will be executed (as root!):                           #
#   => /tech/local/sbin/ignore-NW_down.sh --on                                #
# The thereafter specified command will NOT be executed as root:              #
#   => uptime                                                                 #
# 2. [-S option]                                                              #
# The -S flag causes the 1st specified command/script to be executed as root  #
# and all others therefter will NOT be executed as root (unless they are      #
# specified by: sudo <cmd>).                                                  #
# 3. [-f option]                                                              #
# Script and command will be executed on the systems (once they were tested   #
# to be available) such as specified in the file:                             #
#   => /tmp/system-list                                                       #
# (System can also be specified directly: -s "sys1 sys2 sys3" or by using the #
#  -e|-A|-t input-parameters).                                                #
# 4. [-p option]                                                              #
# Operator won't be prompted for a password, since it was already provided:   #
#   => MyPass01!                                                              #
# 5. [-m option]                                                              #
# All (back-ground) processes may not take longer to complete than:           #
#   => 60 seconds                                                             #
# 6. [-n option]                                                              #
# No more than a maximum of given (back-ground) processes will be operational #
# at the same time:                                                           #
#   => 45 back-ground processes                                               #
# 7. [-w option]                                                              #
# The number of seconds to be waited before checking process(es) are still    #
# running:                                                                    #
#   => 10 seconds                                                             #
# 8. [-w option]                                                              #
# The operator won't be prompted to select/acknowledge the system(s) on which #
# the remote command(s)/script(s) will be launched.                           #
# 9. [-Q option]                                                              #
# Detailed output is not displayed.                                           #
#                                                                             #
# LAST-LINE: DO NOT REMOVE -------------------------------------------------- #
#                                                                             #
###############################################################################
# Define the needed/required variables.                                       #
###############################################################################
InitSettings(){
MAX_PROC=30
MAX_SECS=600
  OUTDIR=/tmp/.rem-exec/$(id -un)/$$ 
 LOGFILE=/tmp/.rem-exec/$(id -un)/.$(basename $0).$$
 SSHPASS=/usr/bin/sshpass
EXCLUDES="kl13322d kl122a91 kl122a80 kl143com kl13843p kl134e1u kl1379vi kl12333c kl1106sd"
}

##############################################################################
# Define variables based on the values of the command-line arguments.        #
##############################################################################
ProcessCMDLineArguments(){ 
while getopts :e:f:m:n:p:s:t:w:x:ADLNSQ FLAG
do
  case ${FLAG} in
     A) [[ -n "${ENV}" || -n "${TYPE}" || -n "${SPECIFIED}" ]] && DisplayErrorAndExit
        TYPE[0]=PLANNED;TYPE[1]=OPERATION ;;
     e) [[ -n "${ENV}" || -n "${TYPE}" || -n "${SPECIFIED}" ]] && DisplayErrorAndExit
        case $(echo ${OPTARG} | awk '{ print toupper($1) }') in
           AE) ENV=AE                     ;;
          AVE) ENV=AVE                    ;;
           DE) ENV=DE                     ;;
           EE) ENV=EE                     ;;
           LE) ENV=LE                     ;;
           SE) ENV=SE                     ;;
           TE) ENV=TE                     ;;
            *) DisplayErrorAndExit        ;;
        esac                              ;;
     f) [[ -n "${ENV}" || -n "${TYPE}" || -n "${SPECIFIED}" ]] && DisplayErrorAndExit
        if [ -s ${OPTARG} ]
        then
            SPECIFIED="$(awk '$1 !~ /^#/ { print $0 }' ${OPTARG})"
        else
            DisplayErrorAndExit
        fi                                ;;
     m) if [ $(echo "${OPTARG}" | egrep ^[[:digit:]]+$ | wc -l) -eq 0 ]
        then
            DisplayErrorAndExit
        else
            MAX_SECS="${OPTARG}"
        fi                                ;;
     n) if [[ $(echo "${OPTARG}" | egrep ^[[:digit:]]+$ | wc -l) -eq 0 || ${OPTARG} -eq 0 || ${OPTARG} -gt 150 ]]
        then
            DisplayErrorAndExit
        else
            MAX_PROC="${OPTARG}"
        fi                                ;;
     p) if [ "${I_AM_ROOT}" != "true" ]
        then
            PASSWORD="${OPTARG}"
        else
            DisplayErrorAndExit
        fi                                ;;
     s) [[ -n "${ENV}" || -n "${TYPE}" || -n "${SPECIFIED}" ]] && DisplayErrorAndExit
        SPECIFIED="${OPTARG}"             ;;
     t) [[ -n "${ENV}" || -n "${TYPE}" || -n "${SPECIFIED}" ]] && DisplayErrorAndExit
        case $(echo ${OPTARG} | awk '{ print toupper($1) }') in
             PLANNED) TYPE=PLANNED        ;;
           OPERATION) TYPE=OPERATION      ;;
                   *) DisplayErrorAndExit ;;
        esac                              ;;
     w) if [[ $(echo "${OPTARG}" | egrep ^[[:digit:]]+$ | wc -l) -eq 0 || ${OPTARG} -eq 0 ]]
        then
            DisplayErrorAndExit
        else
            #
            # Don't allow the sleep-time to be greater than the number of seconds an individual processes may take:
            #
            if [ ${OPTARG} -gt ${MAX_SECS} ]
            then
                SLEEP="${MAX_SECS}"
            else
                SLEEP="${OPTARG}"
            fi
        fi                                ;;
     x) COMMAND="${OPTARG}"               ;;
     D) [[ -n "${DO_NOT_SUDO}"     ]] && DisplayErrorAndExit
        DO_NOT_SUDO=true                  ;;
     L) USE_LOCAL_COPY=true               ;;
     N) CONFIRM=false                     ;;
     Q) QUIET=true                        ;;
     S) [[ -n "${DO_NOT_SUDO}"     ]] && DisplayErrorAndExit
        [[ "${I_AM_ROOT}" = "true" ]] && DisplayErrorAndExit
        DO_NOT_SUDO=false                 ;;
     *) DisplayErrorAndExit               ;;
  esac
done
}

###############################################################################
# Display an error-message in case of wrong input-variables.                  #
###############################################################################
DisplayErrorAndExit(){
echo -e "\n\t$(tput rev)**ERROR**$(tput sgr0) usage: $(basename $0)\n\t\t\t -x \"<command to execute>\"\n\c"
echo -e "\n\t\t\t -A   (=ALL; Planned and Operation)     |\n\c" 
echo -e   "\t\t\t -t <PLANNED  | OPERATION>              |\n\c"
echo -e   "\t\t\t -e <AE | AVE | DE | EE | LE | SE | TE> |\n\c"
echo -e   "\t\t\t -s \"<system> <system> <system> ...\"    |\n\c"
echo -e   "\t\t\t -f  <file>\n\n\c"
echo -e   "\t\t\t -D   (=DO not use sudo) | -S (=do use SUDO)\n\n\c"
echo -e "\t\t       [ -m <max seconds>     ]\n\t\t       [ -n <max processes>   ]\n\c"
[[ "${I_AM_ROOT}" != "true" ]]  &&  echo -e  "\t\t       [ -p <password>        ]\n\c"
echo -e "\t\t       [ -w <waiting seconds> ]\n\c"
echo -e "\t\t       [ -L ] (=use LOCAL copy            )\n\t\t       [ -N ] (=NO confirmations asked    )\n\t\t       [ -Q ] (=QUIET mode                )\n\n"
CleanUpAndExit
}

###############################################################################
# Make sure things are visible again and no passwords kept in shell-history.  #
###############################################################################
CleanUpAndExit(){
rm -rf /tmp/.rem-exec/$(id -un)/$$ 
find   /tmp/.rem-exec/$(id -un) -type f -name ".$(basename $0).[0-9]*" -mtime +10 2>/dev/null | xargs rm -f 
rm -f ~/.kl[0-9]*.$$-auth_s_kl[0-9]*
#
# Have the password removed from the shell-history:
#
if [[ "${I_AM_ROOT}" != "true" && -n "${PASSWORD}" && $(grep -w $(basename $0) ~/.bash_history 2>/dev/null | grep -w "${PASSWORD}" 2>/dev/null | wc -l) -ne 0 ]]
then
    sed -i -e 's/-p'${PASSWORD}'/-pXXXXXXX/g' -e 's/-p '${PASSWORD}'/-p XXXXXXX/g' ~/.bash_history 2>/dev/null
fi
stty echo;echo -e "\n";exit 99
}

###############################################################################
# Determine and set the status for the background process such as it ran.     #
###############################################################################
GetAndSetStatus(){ 
#
# Put the used file-descriptor back into the free file-descriptors pool, upon it is aviable for other background processes to be started in it:
#
FREE_DESCR[${USED_DESCR}]=${USED_DESCR}
#
# Since the background process is not operational anymore, remove it from the RUNNING-array:
#
unset RUNNING[${USED_DESCR}]
#
# Close the used file-descriptor and determine the status of the background process such as it ran in it:
#
           DESC_FILE=${OUTDIR}/.${USED_DESCR}_stdout-$(id -un)::${USED_SYS}
if [ -f "${DESC_FILE}" ]
then
    eval exec "${USED_DESCR}<&-"
    eval exec "${USED_DESCR}<${DESC_FILE}"
    [[ "${QUIET:=false}" != "true" ]] && cat ${DESC_FILE}
    eval $(awk -F: '$1 ~ /^'${USED_SYS}'$/ && $2 ~ /^[0-9]/ { RESULT=$2 }END{ print "RESULT="RESULT }' ${DESC_FILE} 2>/dev/null)
    if [ ${RESULT:-99} -eq 0 ]
    then
        [[ "${QUIET:=false}" != "true" ]] && echo -e "\t     Successfully executed: \"${COMMAND}\" on: ${USED_SYS}"
        ((SUCCEEDED+=1));SUCCEEDED_HOSTS="${SUCCEEDED_HOSTS} ${USED_SYS}"
    else
        [[ "${QUIET:=false}" != "true" ]] && echo -e "\t *** FAILED *** to execute: \"${COMMAND}\" on: ${USED_SYS}"
        ((FAILED+=1))   ;FAILED_HOSTS="${FAILED_HOSTS}       ${USED_SYS}"
    fi
    awk '{ print "'${USED_SYS}':_:"$0 }' ${DESC_FILE} >> ${LOGFILE}
else
    [[     "${QUIET:=false}" != "true" ]] && echo -e "\t *** FAILED *** to execute: \"${COMMAND}\" on: ${USED_SYS}"
    ((    FAILED+=1))   ;FAILED_HOSTS="${FAILED_HOSTS}       ${USED_SYS}"
fi
rm -f ${DESC_FILE} 2>/dev/null
}

################################################################################
# Get a free file-descriptor from descriptors pool.                            #
################################################################################
GetFreeDescriptor(){
#
# If a free file-descriptor is in the descriptors pool, use that 1 to start the background process in and remove it from the pool (since it is not free anymore):
#
         DESCRIPTOR=$(echo      ${FREE_DESCR[@]} 2>/dev/null | awk '{ print $1 }')
[[ -n "${DESCRIPTOR}" ]] && unset FREE_DESCR[${DESCRIPTOR}]
}

###############################################################################
# Manage the running and completed background processes.                      #
###############################################################################
MonitorBackGroundProcs(){ 
#
# Have running background processes properly monitored (do not use the shell-builtin "wait" [it might wait to eternity... :-(]) for their activity:
#
for PROC in ${RUNNING[@]}
do
  eval $(echo  ${PROC} | awk -F: '{ print "PROC="$1,"USED_DESCR="$2,"STARTED="$3,"USED_SYS="$4 }')
  if [ $(ps -p ${PROC} 2>/dev/null | awk '$1 !~ /^PID$/ { print $0 }' | wc -l) -gt 0 ]
  then
      #
      # In case of the background process is still running and longer than the ${MAX_SECS} number of seconds; have it killed:
      #
      if [ $(expr $(date +%s) - ${STARTED}) -gt ${MAX_SECS} ]
      then
          typeset -i ATTEMPT=0
          while [[ ${ATTEMPT} -lt 3 && $(ps -p ${PROC} | wc -l) -eq 2 ]]
          do
                   ((ATTEMPT+=1))
            [[     ${ATTEMPT}    -eq 3     ]] && SIGNAL=9
            [[ "${QUIET:=false}" != "true" ]] && echo -e "\n\tBackground process is running too long for system: ${USED_SYS} ${PROC} will be killed..."
            kill -${SIGNAL:=1} ${PROC} 2>/dev/null
            sleep 0.5
          done
          GetAndSetStatus
      fi
  else
      GetAndSetStatus
  fi
done
if [ ${#RUNNING[@]} -ne 0 ]
then
    if [ "${QUIET:=false}" != "true" ]
    then
        echo -e "\n\tBackground process(es) still running for:"
        echo ${RUNNING[@]} | awk '{ for (i=1;i<=NF;i++) { split( $i, array, ":" ); printf ("%-9s "),array[4] } }END{ print "" }' | fold -sw84 | awk '{ print "\t"$0 }'
        echo -e "\t#Process(es) running: ${#RUNNING[@]} - #Free file-descriptor(s): ${#FREE_DESCR[@]}\n"
    fi
    sleep ${SLEEP:-5}
fi
}

################################################################################
# Ask for the user-password, without having it displayed it on the screen.     #
################################################################################
AskForUserPassword(){
while [[ "${PASS_I:=unknown_I}" != "${PASS_II:=unknown_II}" ]]
do
  echo -e "\n\tPlease enter password for $(id -un): \c";stty -echo; read PASS_I ;stty echo ;echo
  echo -e "\n\tEnter the password again: \c"           ;stty -echo; read PASS_II;stty echo ;echo
  if [[ "${PASS_I:=unknown_I}" != "${PASS_II:=unknown_II}" ]]
  then
      clear;echo -e "\n\tThe password entries do not match or they're empty, please try again."
  else
      export PASSWORD="${PASS_I}"
  fi
done
}

################################################################################
# Get all known systems by type (PLANNED|IN OPERATION) if none specified.      #
################################################################################
GetAllKnownSystems(){ 
#
# Get all known Linux systems from the CMDB if no systems were specified:
#
if [[ -n "${TYPE}" || -n "${ENV}" ]]
then
    eval $(\
    ( echo "SELECT DISTINCT hostname,updatedate,env,function,description from assets WHERE os        != 'vmware'    and
                                                                                           os  NOT LIKE 'VMWARE%'   and
                                                                                           os  NOT LIKE 'Windows%'  and
                                                                                           osversion != 'Appliance' and
                                                                                           os        != 'AIX'       and
                                                                                           os        != 'suse' ORDER BY hostname ASC" \
      | /usr/bin/mysql --skip-column-names -ubdmc -pk1mp0c CMDB2 
    ) | awk -F"\t" '{ if ( $3 ~ /\// )
                          split( $3, env, "/" )
                       else
                          env[2]=$3
                     }
                     #
                     # -1 Exclude ESX systems:
                     # -2 Get only those hosts for which the hostname starts with kl:
                     # -3 If applicable: get the specified environment AE|AVE|DE|EE|LE|SE|TE:
                     # -4 If applicable: get the specified type: PLANNED|OPERATION or both:
                     #
                     tolower($5) !~ /vmware esx server/         && \
                     $1           ~ /^kl/                       && \
                     env[2]       ~ /'${ENV:-E}'$/              && \
                   ( $4           ~ /'${TYPE[0]:-[A-Z][A-Z]}'$/ || $4 ~ /'${TYPE[1]:-do_not_use}'$/ ) { print $1                    }' 2>/dev/null | sort -nr | uniq \
                                                                 | awk 'BEGIN{ i=0 }                  { print "SYSTEMS["i"]="$1;i++ }')

else
    eval $(echo ${SPECIFIED} | tr "[,| ]" "\n" | sort -nr | uniq | awk 'BEGIN{ i=0 } $1 ~ /^kl/       { print "SYSTEMS["i"]="$1;i++ }' 2>/dev/null)
fi
}

################################################################################
# Columns in selection screen.                                                 #
################################################################################
DefineColumnsInSystemsScreen(){
USENUM=$1
awk 'BEGIN{ columns=1;usenum='${USENUM}' } { for ( i=0;i<NF ;i++ ) { j=i+1
                                               { if ( usenum == 1 )
                                                    printf ("%04d:%-19s"),i,$j
                                                 else
                                                    printf ("%-23s")       ,$j
                                               }
                                               { if ( columns == '${COLUMNS}'-1 )
                                                    { columns=1;print "" }
                                                 else
                                                      columns++
                                               }
                                             } }' | awk '{ sub(/^[ ]+/, ""); print "\t"$0 }END{ print "\n" }'
}

################################################################################
# Get a specific system(s) from the ${SYSTEMS[@]} array.                       #
################################################################################
GetSpecificSystem(){
while [ "${BREAK:=false}" != "true"  ]
do
  clear
  echo -e "\n\t$(tput rev)Available system(s):$(tput sgr0)\n"
  COLUMNS=$(eval expr $(tput cols) / 23)
  echo ${SYSTEMS[@]}  | DefineColumnsInSystemsScreen 1
  echo -e   "\t$(tput rev) Selected system(s):$(tput sgr0)\n"
  echo ${SELECTED[@]} | DefineColumnsInSystemsScreen 0
  echo "_________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________" | fold  -w$(expr $(tput cols) - 9  2>/dev/null) | awk '{ print "\t"$0;exit }'
  echo -e "\t$(tput smul)Select$(tput rmul) a system by typing its number (or range: X,XX):"
  echo -e "\t\t\t\t\t (Or for $(tput smul)all systems$(tput rmul)):   @"
  echo -e "\t\t\t\t\t\t  $(tput smul)Acknowlegde$(tput rmul): [a|A]"
  echo -e "\t\t\t\t\t\t         $(tput smul)Quit$(tput rmul): [q|Q]"
  echo -e "\t\t\t\t\t\t        $(tput smul)Reset$(tput rmul): [r|R]"
  echo -e "\t\t\t\t\t      $(tput rev)Your choice ==>:$(tput sgr0)   \c"
  read   SELECTED_SYSTEM
         SELECTED_SYSTEM=$(echo ${SELECTED_SYSTEM} | awk '{ { if ( $1 !~ /,/ )
                                                              { while( $1 ~ /^0/ && length($1) > 1 ) gsub( "^0", "", $1 ) }
                                                             }
                                                             print $1 }')
  case ${SELECTED_SYSTEM} in
      [0-9]|\
      [0-9][0-9]|\
      [0-9][0-9][0-9]|\
      [0-9][0-9][0-9][0-9]) #
                            # Selection such as done per system:
                            #
                            if [[ ${SELECTED_SYSTEM} -le ${#SYSTEMS[@]} && "${SYSTEMS[${SELECTED_SYSTEM}]}" !=  "........" ]]
                            then
                                declare -a SELECTED=(${SELECTED[@]} ${SYSTEMS[${SELECTED_SYSTEM}]})
                                eval                                  SYSTEMS[${SELECTED_SYSTEM}]="........"
                            fi                                              ;;
             *[0-9],[0-9]*) #
                            # Selection for a range of systems:
                            #
                            eval $(echo ${SELECTED_SYSTEM} | awk -F, '{ print "BEGIN="$1,"END="$2 }')
                            if [[ -n "${BEGIN}" && -n "${END}" && \
                                      ${BEGIN} -lt     ${END}  && \
                                        ${END} -le ${#SYSTEMS[@]} ]]
                            then
                                LAST=$(expr ${END} - ${BEGIN})
                                typeset -i NUM=0 
                                while [  ${NUM} -le ${LAST} ]
                                do
                                  declare -a SELECTED=(${SELECTED[@]} ${SYSTEMS[${BEGIN}]})
                                  eval                                  SYSTEMS[${BEGIN}]="........"
                                  ((BEGIN+=1));((NUM+=1))
                                done
                            fi                                              ;;
                       a|A) unset SYSTEMS;BREAK=true
                            SYSTEMS="${SELECTED[@]}"                        ;;
                       p|P) echo -e "\n"
                            for TEMP_SYS in ${SELECTED[@]}
                            do
                              awk -F"\t" '$1 ~ /^'${TEMP_SYS}'$/ { print $0 }' ${CMDB} | sort | uniq
                            done
                            echo -e "\n\tHit <ENTER> to continue..."
                            read dummy                                      ;;
                       q|Q) echo -e "\n\n\t\tExiting...\n\n";CleanUpAndExit ;;
                       r|R) unset SELECTED
                            GetAllKnownSystems                              ;;
                         @) GetAllKnownSystems
                            declare -a SELECTED=(${SYSTEMS[@]})
                            typeset -i NUM=0
                            while [  ${NUM} -lt ${#SYSTEMS[@]} ]
                            do
                              eval SYSTEMS[${NUM}]="........"
                              ((NUM+=1))
                            done                                            ;;
                         *) unset SELECTED_SYSTEM                           ;;
  esac
done
clear;unset SELECTED BREAK
}

################################################################################
# Setup to SSH-session and perform the remote-execution (as root: with sudo).  #
################################################################################
PerformRemoteExecute(){ 
      PASSWORD=$1
REMOTE_COMMAND=$2
#
# For/on the specified (and valid) system, carry out the specified command (as root: by using sudo), in case of ${USE_LOCAL_COPY} was set to true
# the local script will be copied over to /tmp on the remote-system and that one will then be executed:
#
if [[ -z "${REMOTE_COMMAND}" && ${USE_LOCAL_COPY:-false} = true ]]
then
    TARGET=/tmp/.$(id -un)/$$/$(basename $(echo ${COMMAND} | awk '{ print $1 }'))
    ${SSHPASS} -p ${PASSWORD} ssh -qto ConnectTimeout=5 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o BatchMode=no -l $(id -un) ${SYSTEM} "mkdir -p                  $(dirname ${TARGET})"
    ${SSHPASS} -p ${PASSWORD} scp -qpo ConnectTimeout=5 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o BatchMode=no $(echo ${COMMAND} | awk '{ print $1 }') $(id -un)@${SYSTEM}:${TARGET}
    ${SSHPASS} -p ${PASSWORD} ssh -qto ConnectTimeout=5 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o BatchMode=no -l $(id -un) ${SYSTEM} "chmod u+x                           ${TARGET}"
    REMOTE_COMMAND="${TARGET} $(echo ${COMMAND} | awk '{ $1=""; print $0 }')"
fi
if [ "${DO_NOT_SUDO:=false}" = "true" ]
then
    if [ "${I_AM_ROOT}" != "true" ]
    then
        ${SSHPASS} -p ${PASSWORD} ssh -qto ConnectTimeout=5 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o BatchMode=no -l $(id -un) ${SYSTEM}  "${REMOTE_COMMAND:-${COMMAND}}"   ; RC=$?
    else
        su - sftuser -c          "ssh -qTo ConnectTimeout=5 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o BatchMode=no -l sftuser   ${SYSTEM} \"${REMOTE_COMMAND:-${COMMAND}}\"" ; RC=$?
    fi
else
    #
    # If the user does has the right SUDO-rules set/attached to it, and when literally "no_password" was passed on to the script, then go into the routine for where
    # no password is used for the sudo-command:
    #
    if [ "${PASSWORD:-none}" != "no_password" ]
    then
        #
        # There is no other way to get around the issue the given password is vissible in the systems process-list than storing it in a temp file and having the file removed,
        # locally and remote, right after it was copied/used (=validated by sudo -Si ):
        #
        echo "${PASSWORD}" > ~/.${SYSTEM}.$$-auth_s_${SYSTEM}
        chmod 600            ~/.${SYSTEM}.$$-auth_s_${SYSTEM}
        ${SSHPASS} -p ${PASSWORD} scp -qpo  ConnectTimeout=5 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
                                        -o  BatchMode=no ~/.${SYSTEM}.$$-auth_s_${SYSTEM} $(id -un)@${SYSTEM}:.${SYSTEM}.$$-auth_t_${SYSTEM}
        rm   -f              ~/.${SYSTEM}.$$-auth_s_${SYSTEM}
        ${SSHPASS} -p ${PASSWORD} ssh -qtto ConnectTimeout=5 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
                                         -o BatchMode=no -l                               $(id -un) ${SYSTEM} "\
        sudo -Si <           ~/.${SYSTEM}.$$-auth_t_${SYSTEM} 2>/dev/null
        rm   -f              ~/.${SYSTEM}.$$-auth_t_${SYSTEM} 
        sudo -ni ${REMOTE_COMMAND:-${COMMAND}}
        "
        RC=$?
    else
        #
        # The ${SSHPASS} -p no_password is just to prevent hanging sessions; but for systems on which the SSH-keys are distributed the it is not required:
        #
        ${SSHPASS} -p no_password ssh -qtto ConnectTimeout=5 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -o BatchMode=no -l $(id -un) ${SYSTEM} \
        "sudo -n ${REMOTE_COMMAND:-${COMMAND}}"
        RC=$?
    fi
fi
return ${RC}
}

################################################################################
# Steering of launching remote-commands on available systems.                  #
################################################################################
LaunchRemoteCMDS(){ 
rm    -f ${OUTDIR}/.[0-9]*_stdout-$(id -un)::* 2>/dev/null
#
# Test whether the provided password is correct and if the user is capable to logon by using ssh and does have Sudo-access on the 1st specified system (which is not to be
# excluded by default):
#
typeset -i NUM=0
while [[ $(echo ${EXCLUDES} | grep -wc $(echo ${SYSTEMS} | awk '{ print $(1+'${NUM}') }')) -eq 1 && ${NUM} -lt $(echo ${SYSTEMS} | wc -w) ]]
do
  ((NUM+=1))
done
   ALL=$(echo ${SYSTEMS} | wc -w)
SYSTEM=$(echo ${SYSTEMS} | awk '{ print $(1+'${NUM}') }')
PerformRemoteExecute ${PASSWORD:-none} "/usr/bin/id -un" 1>/dev/null 2>&1
if [ $? -eq 0 ]
then
    echo                                   -e "\n\t  [ok]     Verified the provided password is correct to logon to: ${SYSTEM}"
    [ "${DO_NOT_SUDO}" = "false" ] && echo -e   "\t  [ok]                       and that you do have sudo-access on: ${SYSTEM}"
    if [ "${QUIET:=false}" = "true" ]
    then
        echo                               -e "\n\t [info]    $(basename $0) is running in "quiet mode", as such not much will be displayed."
        echo                               -e   "\t           Please be patient when $(basename $0) is running...\n"
    else
        echo                               -e   "\t  [ok]     \tProceeding...\n"
    fi
    sleep 1
else
    echo                                   -e "\n\t[*ERROR*]  Established that either the provided password is incorrect on: ${SYSTEM}"
    [ "${DO_NOT_SUDO}" = "false" ] && echo -e   "\t[*ERROR*]                               or you don't have sudo-access on: ${SYSTEM}"
    echo                                   -e   "\t[*ERROR*]  \tExiting...\n"
    CleanUpAndExit
fi
#
# Initiate the free file-descriptors pool:(the +3 is due to the fact the first 2 file-descriptors can not be used (stdout and stderr); will start from the 3rd descriptor):
#
typeset -i NUM=3 EXCLUDED=0 UNAVAILABLE=0 FAILED=0 SUCCEEDED=0 DONE=1
while [  ${NUM} -lt $(expr ${MAX_PROC} + 3) ]
do
  FREE_DESCR[${NUM}]=${NUM};((NUM+=1))
done
for SYSTEM in ${SYSTEMS}
do
  PROGRESS="$(echo ${DONE} ${ALL} | awk '{ printf "(#%04d of %04d)\n",$1,$2 }')"
  #
  # Test whether ${SYSTEM} is 1 of the systems which have to be excluded by default:
  #
  if [ $(echo ${EXCLUDES} | grep -wc ${SYSTEM}) -ne 0 ] 
  then
      ((EXCLUDED+=1));EXCLUDED_HOSTS="${EXCLUDED_HOSTS} ${SYSTEM}"
      [[     "${QUIET:=false}" != "true" ]] && printf "\n\t%32s %-30s\n\n" "${SYSTEM} ${PROGRESS}:" "is excluded by default..."
  else
      #
      # Test whether ${SYSTEM}'s hostname can be resolved and if it is reachable over the network:
      #
      host ${SYSTEM} 1>/dev/null 2>&1
      if [[ $? -ne 0 || $(/usr/local/bin/tcping -qt1 -u1 ${SYSTEM} 22 1>/dev/null 2>&1;echo $?) -ne 0 ]]
      then
          ((UNAVAILABLE+=1));UNAVAILABLE_HOSTS="${UNAVAILABLE_HOSTS} ${SYSTEM}"
          [[ "${QUIET:=false}" != "true" ]] && printf "\n\t%32s %-30s\n\n" "${SYSTEM} ${PROGRESS}:" "seems to be UNavailable..."
      else
          #
          # Very first step in processing is to obtain a free file-descriptor, or just wait for 1 to become available:
          #
          unset        DESCRIPTOR
          while [ -z ${DESCRIPTOR} ]
          do
            GetFreeDescriptor
            [[    -z ${DESCRIPTOR} ]] && MonitorBackGroundProcs
          done
          #
          # Once detected the ${SYSTEM} is operational, have the he remote-execution (by root) carried out:
          #
          [[ "${QUIET:=false}" != "true" ]] && printf "\t%32s %-30s\n" "${SYSTEM} ${PROGRESS}:" "seems to be operational, let's go..."
          eval exec "${DESCRIPTOR}>${OUTDIR}/.${DESCRIPTOR}_stdout-$(id -un)::${SYSTEM}"
          ( PerformRemoteExecute ${PASSWORD:-none}  
            echo ${SYSTEM}:$?
          ) 1>&${DESCRIPTOR} 2>/dev/null &
          RUNNING[${DESCRIPTOR}]=$!:${DESCRIPTOR}:$(date +%s):${SYSTEM}
      fi
  fi
  ((DONE+=1))
done
#
# Wait for all background remote-cmd processes to complete:
#
while [ ${#RUNNING[@]} -ne 0 ]
do
  MonitorBackGroundProcs
done
#
# Have the grand-totals regarding the run displayed:
#
( echo
  echo    ${EXCLUDED_HOSTS} | fold -sw120 | awk '{ sub(/^[ ]+/, "" ); print    "EXCLUDED_HOSTS="$0 }' 
  echo ${UNAVAILABLE_HOSTS} | fold -sw120 | awk '{ sub(/^[ ]+/, "" ); print "UNAVAILABLE_HOSTS="$0 }' 
  echo   ${SUCCEEDED_HOSTS} | fold -sw120 | awk '{ sub(/^[ ]+/, "" ); print "  SUCCEEDED_HOSTS="$0 }' 
  echo      ${FAILED_HOSTS} | fold -sw120 | awk '{ sub(/^[ ]+/, "" ); print "     FAILED_HOSTS="$0 }' 
  echo
) >>       ${LOGFILE}
( echo -e "\n\t     Total number of - excluded systems: ${EXCLUDED:=0}"
  echo -e   "\t                  - systems unavailable: ${UNAVAILABLE:=0}"
  echo -e   "\tRemote commands - successfully executed: ${SUCCEEDED:=0}"
  echo -e   "\t                      failed to execute: ${FAILED:=0}"
  echo -e   "\t---------------------------------------:----------"
  echo -e   "\t                                       : $(echo ${EXCLUDED} ${UNAVAILABLE} ${SUCCEEDED} ${FAILED} | awk '{ print $1+$2+$3+$4 }')\n" 
) | tee -a ${LOGFILE}
  echo -e "\n\n\t(For details regarding this session, check: ${LOGFILE})\n"
}

################################################################################
# Ask to proceed when is established lancher is started interactively.         #
################################################################################
AskToProceed(){
if [ $(tty 1>/dev/null 2>&1;echo $?) -eq 0 ]
then
    echo -e   "\n\t          Do you wish to proceed? [Y|N] ==>: \c"
    read   PROCEED
    case ${PROCEED} in
        n|N) CleanUpAndExit ;;
        y|Y) PROCEED=true   ;;
          *) unset PROCEED  ;;
    esac
else
    PROCEED=true
fi
}

############################## Main Script #####################################
#______________________________________________________________________________#
#                                                                              #
trap 'CleanUpAndExit' 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
InitSettings
#
# Act accordingly when the user is logged on as root:
#
if [ $(id -un) = "root" ]
then
    while [ -z "${PROCEED}" ]
    do
      clear
      echo -e "\n\n\t $(tput rev)**NOTE**$(tput sgr0) You're logged on as root ..."
      echo -e     "\t          Therefore the user sftuser (without sudo!) will be used."
      AskToProceed
    done
    I_AM_ROOT=true  
else
    I_AM_ROOT=false 
fi
# 
# When the ${OUTDIR}-directory doesn't exist it is assumed the tool is being used for the very first time by $(id -un), display a screen containing some warnings and  
# the instructions regarding the usage (from the upper part of this script):
#
if [ ! -d $(dirname ${OUTDIR}) ]
then
    eval $(awk '$1 ~ /^#$/ && $2 ~ /^START-LINE:$/ { print "BEGIN="NR      }
                $1 ~ /^#$/ && $2 ~ /^LAST-LINE:$/  { print  "LAST="NR;break }' $0 2>/dev/null)
    while [ -z "${PROCEED}" ]
    do
      clear
      ( echo -e "\n\n\t $(tput rev)**NOTE**$(tput sgr0) First time usage detected for: $(id -un)\n"
        awk 'NR>'${BEGIN}' && NR<'${LAST}' { sub( "^#", "", $0 )  
                                             sub( "#$", "", $0 ) ; print "\t"$0 }END{ print "\t\t--------------------------------------------------------------------" }' $0 ) | more
      AskToProceed
    done
fi
mkdir -p ${OUTDIR}
#
# Define variables based on the values of the command-line arguments:
#
ProcessCMDLineArguments "$@" 
#
# Only proceed when determined the right/required input parameters were passed on the script:
#
[[ -z "${DO_NOT_SUDO}" || -z "${COMMAND}" || ( -z "${ENV}" && -z "${TYPE}" && -z "${SPECIFIED}" ) ]] && DisplayErrorAndExit
#
# The input variable may(!) contain the user-password, otherwise the script will ask for it (without the password no "sudo su-" can be done...):
#
[[ "${I_AM_ROOT}" != "true" && -z "${PASSWORD}" ]] && AskForUserPassword
#
# Firstly have the password removed from the shell-history:
#
if [[ "${I_AM_ROOT}" != "true" && -n "${PASSWORD}" && $(grep -w $(basename $0) ~/.bash_history 2>/dev/null | grep -w "${PASSWORD}" 2>/dev/null | wc -l) -ne 0 ]]
then
    sed -i -e 's/-p'${PASSWORD}'/-pXXXXXXX/g' -e 's/-p '${PASSWORD}'/-p XXXXXXX/g' ~/.bash_history 2>/dev/null
fi
echo -e "\n$(date): $(basename $0) $@ \n" | awk '{ print "## "$0 }' > ${LOGFILE}
GetAllKnownSystems
#
# Do not ask to confirm or select systems when the -N flag was passed on to the script:
#
if [ "${CONFIRM:=true}" = "true" ]
then
    GetSpecificSystem
else
    SYSTEMS="${SYSTEMS[@]}"
fi
#
# In case of using a local script (to be executed on on the remote-system(s)) have it displayed in the logfile:
#
[[ "${USE_LOCAL_COPY}" = "true" && -s $(echo ${COMMAND} | awk '{ print $1 }') ]] && awk -v file=$(basename $(echo ${COMMAND} | awk '{ print $1 }')) \
                                                                                           'BEGIN{ print "\n##LOCAL-SCRIPT:########################################################" }
                                                                                                 { print   "##"file":# "$0 }
                                                                                              END{ print   "##LOCAL-SCRIPT:############### "FILENAME"\n" 
                                                                                                 }' $(echo ${COMMAND} | awk '{ print $1 }') >> ${LOGFILE}
#
# When all conditions are met, go launch the command/script (that is where it all happens...):
#
[[ -n "${SYSTEMS[@]}" ]] && LaunchRemoteCMDS
CleanUpAndExit
#______________________________________________________________________________#
#                                                                              #
############################# End Of Script ####################################
